"""
Manga Downloader Telegram Bot
Usage: Send manga URL to bot, it will send you the PDF
"""

import os
import tempfile
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import requests
from bs4 import BeautifulSoup
import re
from PIL import Image
from io import BytesIO
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
import time
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot token - GET THIS FROM @BotFather
BOT_TOKEN = "7885431908:AAHUwcKwS7ua_9ZEiZauAO3BZ5JJttjJZSY"

class MangaScraper:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.driver = None
    
    def get_driver(self):
        if self.driver is None:
            chrome_options = Options()
            chrome_options.add_argument('--headless')
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_options.add_argument(f'user-agent={self.headers["User-Agent"]}')
            
            try:
                service = Service(ChromeDriverManager().install())
                self.driver = webdriver.Chrome(service=service, options=chrome_options)
            except Exception as e:
                logger.error(f"Chrome error: {e}")
                return None
        return self.driver
    
    def detect_site(self, url):
        if 'asuracomic' in url or 'asura' in url:
            return 'asura'
        elif 'mangadex' in url:
            return 'mangadex'
        elif 'manganato' in url:
            return 'manganato'
        return 'generic'
    
    def scrape_asura(self, url):
        driver = self.get_driver()
        if not driver:
            return None
        
        try:
            logger.info(f"Loading Asura: {url}")
            driver.get(url)
            time.sleep(5)
            
            html = driver.page_source
            soup = BeautifulSoup(html, 'html.parser')
            
            # Get title
            title = 'Unknown Manga'
            for selector in ['h1', 'h2', 'h3']:
                elem = soup.select_one(selector)
                if elem and len(elem.text.strip()) > 3:
                    title = elem.text.strip()
                    break
            
            # Get chapters
            chapters = []
            for link in soup.find_all('a', href=True):
                href = link.get('href', '')
                text = link.text.strip()
                
                if '/chapter/' in href and 'chapter' in text.lower():
                    num_match = re.search(r'chapter[:\s-]*(\d+)', text, re.I)
                    if num_match:
                        num = num_match.group(1)
                        if not href.startswith('http'):
                            from urllib.parse import urljoin
                            href = urljoin(url, href)
                        chapters.append({
                            'number': num,
                            'title': text,
                            'url': href
                        })
            
            # Remove duplicates
            seen = set()
            unique = []
            for ch in chapters:
                if ch['url'] not in seen:
                    seen.add(ch['url'])
                    unique.append(ch)
            
            try:
                unique.sort(key=lambda x: float(x['number']))
            except:
                pass
            
            logger.info(f"Found {len(unique)} chapters")
            return {'title': title, 'chapters': unique}
            
        except Exception as e:
            logger.error(f"Scrape error: {e}")
            return None
    
    def create_simple_pdf(self, manga_title, chapters, output_path):
        """Create a simple text-based PDF with chapter info"""
        try:
            c = canvas.Canvas(output_path, pagesize=A4)
            width, height = A4
            
            # Cover page
            c.setFont("Helvetica-Bold", 28)
            c.drawString(50, height - 100, manga_title[:40])
            c.setFont("Helvetica", 16)
            c.drawString(50, height - 140, f"{len(chapters)} Chapters")
            c.setFont("Helvetica", 10)
            c.drawString(50, height - 170, "Generated by Manga Downloader Bot")
            c.showPage()
            
            # Chapter list
            for idx, ch in enumerate(chapters):
                c.setFont("Helvetica-Bold", 14)
                c.drawString(50, height - 80, f"Chapter {ch['number']}")
                c.setFont("Helvetica", 11)
                
                # Wrap long titles
                title_text = ch['title'][:70]
                c.drawString(50, height - 105, title_text)
                
                c.setFont("Helvetica", 8)
                c.drawString(50, height - 125, f"URL: {ch['url'][:80]}")
                
                c.setFont("Helvetica-Oblique", 9)
                c.drawString(50, height - 145, f"Chapter {idx + 1} of {len(chapters)}")
                
                c.showPage()
            
            c.save()
            logger.info(f"PDF created: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"PDF creation error: {e}")
            return False

scraper = MangaScraper()

# Store user data temporarily
user_data = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send welcome message"""
    welcome_text = """
ğŸŒ **Manga Downloader Bot**

HoÅŸ geldiniz! Manga indirmek iÃ§in:

1ï¸âƒ£ Manga sitesinin linkini gÃ¶nderin
2ï¸âƒ£ Chapter'larÄ± seÃ§in
3ï¸âƒ£ PDF olarak indirin!

**Desteklenen siteler:**
âœ… Asura Scans
âœ… MangaDex
âœ… Manganato
âœ… DiÄŸerleri (deneysel)

**Ã–rnek:**
`https://asuracomic.net/series/the-greatest-estate-developer-e53d30f2`

Hadi baÅŸlayalÄ±m! ğŸš€
"""
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send help message"""
    help_text = """
ğŸ“– **NasÄ±l KullanÄ±lÄ±r:**

1. Manga sitesinin linkini bana gÃ¶nderin
2. Chapter listesini gÃ¶receÄŸiniz
3. KaÃ§ chapter istediÄŸinizi seÃ§in (Ã¶rn: `1-10` veya `5` veya `all`)
4. PDF'iniz hazÄ±rlanacak!

**Komutlar:**
/start - BaÅŸlat
/help - YardÄ±m
/cancel - Ä°ptal

**Ä°puÃ§larÄ±:**
â€¢ Ã‡ok fazla chapter seÃ§erseniz uzun sÃ¼rebilir
â€¢ Ä°lk denemede 1-5 chapter ile test edin
â€¢ PDF boyutu 50MB'Ä± geÃ§emez (Telegram limiti)
"""
    await update.message.reply_text(help_text, parse_mode='Markdown')

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel operation"""
    user_id = update.effective_user.id
    if user_id in user_data:
        del user_data[user_id]
    await update.message.reply_text("âŒ Ä°ÅŸlem iptal edildi.")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle incoming messages"""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    # Check if it's a URL
    if text.startswith('http'):
        await update.message.reply_text("ğŸ” Sayfa analiz ediliyor...\nBu 10-15 saniye sÃ¼rebilir...")
        
        # Scrape the manga
        result = scraper.scrape_asura(text)
        
        if not result or not result.get('chapters'):
            await update.message.reply_text(
                "âŒ Chapter bulunamadÄ±!\n\n"
                "LÃ¼tfen doÄŸru link gÃ¶nderdiÄŸinizden emin olun.\n"
                "Desteklenen siteler: Asura Scans, MangaDex, Manganato"
            )
            return
        
        # Store data
        user_data[user_id] = result
        
        manga_title = result['title']
        total_chapters = len(result['chapters'])
        
        # Show info
        info_text = f"""
âœ… **Bulundu!**

ğŸ“š **Manga:** {manga_title}
ğŸ“– **Chapter SayÄ±sÄ±:** {total_chapters}

**Chapter aralÄ±ÄŸÄ± seÃ§in:**

Ã–rnekler:
â€¢ `1-10` â†’ Ä°lk 10 chapter
â€¢ `50` â†’ Sadece 50. chapter
â€¢ `1-5,10,15-20` â†’ Belirli chapter'lar
â€¢ `all` â†’ TÃ¼m chapter'lar (dikkat: uzun sÃ¼rer!)

âš ï¸ **UyarÄ±:** 
â€¢ Ä°lk denemede 1-5 chapter tavsiye edilir
â€¢ PDF dosyasÄ± 50MB'Ä± geÃ§emez
"""
        await update.message.reply_text(info_text, parse_mode='Markdown')
        
    elif user_id in user_data:
        # Parse chapter selection
        await process_chapter_selection(update, context, text)
    else:
        await update.message.reply_text(
            "â“ LÃ¼tfen Ã¶nce bir manga linki gÃ¶nderin!\n\n"
            "Ã–rnek: https://asuracomic.net/series/manga-name"
        )

async def process_chapter_selection(update: Update, context: ContextTypes.DEFAULT_TYPE, selection: str):
    """Process chapter selection and create PDF"""
    user_id = update.effective_user.id
    
    if user_id not in user_data:
        await update.message.reply_text("âŒ Ã–nce bir manga linki gÃ¶nderin!")
        return
    
    manga_data = user_data[user_id]
    all_chapters = manga_data['chapters']
    manga_title = manga_data['title']
    
    try:
        # Parse selection
        selected_indices = []
        
        if selection.lower() == 'all':
            selected_indices = list(range(len(all_chapters)))
        else:
            # Parse ranges like "1-10,15,20-25"
            parts = selection.split(',')
            for part in parts:
                part = part.strip()
                if '-' in part:
                    start, end = part.split('-')
                    start_idx = int(start) - 1
                    end_idx = int(end)
                    selected_indices.extend(range(start_idx, end_idx))
                else:
                    selected_indices.append(int(part) - 1)
        
        # Filter valid indices
        selected_indices = [i for i in selected_indices if 0 <= i < len(all_chapters)]
        selected_chapters = [all_chapters[i] for i in selected_indices]
        
        if not selected_chapters:
            await update.message.reply_text("âŒ GeÃ§ersiz seÃ§im! Ã–rnek: `1-10` veya `all`")
            return
        
        # Limit to prevent abuse
        if len(selected_chapters) > 20:
            await update.message.reply_text(
                f"âš ï¸ Ã‡ok fazla chapter! (seÃ§ilen: {len(selected_chapters)})\n\n"
                "Maksimum 20 chapter seÃ§ebilirsiniz.\n"
                "Daha az chapter seÃ§in."
            )
            return
        
        await update.message.reply_text(
            f"ğŸ“¥ PDF oluÅŸturuluyor...\n\n"
            f"Manga: {manga_title}\n"
            f"Chapter sayÄ±sÄ±: {len(selected_chapters)}\n\n"
            f"â³ LÃ¼tfen bekleyin..."
        )
        
        # Create PDF
        temp_dir = tempfile.gettempdir()
        pdf_path = os.path.join(temp_dir, f"manga_{user_id}.pdf")
        success = scraper.create_simple_pdf(manga_title, selected_chapters, pdf_path)
        
        if success and os.path.exists(pdf_path):
            # Send PDF
            with open(pdf_path, 'rb') as pdf_file:
                await update.message.reply_document(
                    document=pdf_file,
                    filename=f"{manga_title[:30]}.pdf",
                    caption=f"âœ… **{manga_title}**\n\n{len(selected_chapters)} chapter PDF olarak hazÄ±r!"
                )
            
            # Cleanup
            os.remove(pdf_path)
            await update.message.reply_text(
                "ğŸ‰ BaÅŸarÄ±yla indirildi!\n\n"
                "BaÅŸka manga indirmek iÃ§in yeni link gÃ¶nderin."
            )
        else:
            await update.message.reply_text("âŒ PDF oluÅŸturulamadÄ±. LÃ¼tfen tekrar deneyin.")
    
    except Exception as e:
        logger.error(f"Selection error: {e}")
        await update.message.reply_text(
            f"âŒ Hata oluÅŸtu: {str(e)}\n\n"
            "LÃ¼tfen geÃ§erli bir format kullanÄ±n.\n"
            "Ã–rnek: `1-10` veya `5` veya `all`"
        )

def main():
    """Start the bot"""
    # Create application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("cancel", cancel))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Start bot
    logger.info("ğŸ¤– Bot starting...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
